{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/Users/joel/Code/joelhooks/cueplayer-react/src/components/player.tsx\";\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from 'react';\nimport Hls from 'hls.js';\nimport create from 'zustand';\nimport { devtools } from 'zustand/middleware';\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'SET_CAPTION':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentCaption: action.text\n      });\n\n    case 'TIME_CHANGE':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentTime: action.currentTime\n      });\n\n    case 'PLAYER_UPDATE':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        player: action.player\n      });\n\n    case 'SET_DURATION':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        duration: action.duration\n      });\n  }\n};\n\nexport const usePlayerStore = create(devtools(set => ({\n  player: null,\n  currentTime: 0,\n  duration: 0,\n  currentCaption: ' ',\n  dispatch: args => set(state => reducer(state, args))\n})));\nexport const useVideo = videoOptions => {\n  const videoNode = React.useRef();\n  const [ready, setReady] = React.useState(false);\n  const changedKey = JSON.stringify(videoOptions);\n  const dispatch = usePlayerStore(React.useCallback(state => state.dispatch, []));\n  const onPlayerProgress = React.useCallback(e => {\n    const player = e.target;\n    dispatch({\n      type: 'TIME_CHANGE',\n      currentTime: player.currentTime\n    });\n  }, [dispatch]);\n  React.useEffect(() => {\n    var _videoNode$current;\n\n    fetch('/notes.vtt');\n    (_videoNode$current = videoNode.current) === null || _videoNode$current === void 0 ? void 0 : _videoNode$current.addTextTrack('metadata', 'notes');\n  }, [videoNode]);\n  React.useEffect(() => {\n    const player = videoNode.current;\n    const hlsConfig = {\n      enableWorker: true\n    };\n\n    function initPlayer(video) {\n      const hls = new Hls(_objectSpread({}, hlsConfig));\n      hls.attachMedia(video);\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        hls.loadSource(videoOptions.url);\n        hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {\n          console.log('manifest loaded, found ' + data.levels.length + ' quality level', data.levels);\n          setReady(true);\n        });\n      });\n      hls.on(Hls.Events.ERROR, function (event, data) {\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              hls.startLoad();\n              break;\n\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              hls.recoverMediaError();\n              break;\n\n            default:\n              initPlayer(video);\n              break;\n          }\n        }\n      });\n      return hls;\n    }\n\n    function onDurationChange() {\n      dispatch({\n        type: 'SET_DURATION',\n        duration: (player === null || player === void 0 ? void 0 : player.duration) || 0\n      });\n    }\n\n    function onMetadataLoaded() {\n      const textTracks = player === null || player === void 0 ? void 0 : player.textTracks[0];\n      textTracks.mode = 'hidden';\n      const cues = textTracks.cues;\n\n      for (let index = 0; index < cues.length; index++) {\n        var cue = cues[index];\n\n        cue.onenter = e => {\n          const cue = e.target;\n          dispatch({\n            type: 'SET_CAPTION',\n            text: cue.text\n          });\n        }; // cue.onexit = cueExit\n\n      }\n    }\n\n    function addEventListeners() {\n      const tracks = player.textTracks;\n\n      tracks.onaddtrack = e => {\n        const track = e.track;\n\n        track.oncuechange = e => {\n          const activeCues = Array.from(e.currentTarget.activeCues);\n          const cue = activeCues[0];\n          if (!cue) return;\n\n          switch (track.kind) {\n            case 'subtitles':\n              track.mode = 'hidden'; // if(cue) {\n              //   dispatch({type: 'SET_CAPTION', text: cue.text})\n              // } else {\n              //   dispatch({type: 'SET_CAPTION', text: ''})\n              // }\n\n              break;\n\n            case 'metadata':\n              console.log(cue);\n              console.log(cue.text);\n              break;\n          }\n        };\n      };\n\n      player.addEventListener('timeupdate', onPlayerProgress);\n      player.addEventListener('durationchange', onDurationChange);\n      player === null || player === void 0 ? void 0 : player.addEventListener('loadedmetadata', onMetadataLoaded);\n    }\n\n    function removeEventListeners() {\n      player === null || player === void 0 ? void 0 : player.removeEventListener('timeupdate', onPlayerProgress);\n      player === null || player === void 0 ? void 0 : player.removeEventListener('durationchange', onDurationChange);\n      player === null || player === void 0 ? void 0 : player.removeEventListener('loadedmetadata', onMetadataLoaded);\n    }\n\n    if (Hls.isSupported()) {\n      const hls = player && initPlayer(player);\n      dispatch({\n        type: 'PLAYER_UPDATE',\n        player\n      });\n      addEventListeners();\n      return () => {\n        if (hls != null) {\n          hls.destroy();\n        }\n\n        removeEventListeners();\n      };\n    } else if (player !== null && player !== void 0 && player.canPlayType('application/vnd.apple.mpegurl')) {\n      // we have to branch on ios because it plays hls natively\n      // and requires a different approach ðŸ˜­\n      player.src = videoOptions.url;\n      setReady(true);\n      addEventListeners();\n      return () => {\n        removeEventListeners();\n      };\n    }\n  }, [videoOptions, videoNode, dispatch, onPlayerProgress]);\n  const Video = React.useCallback((_ref) => {\n    let {\n      children\n    } = _ref,\n        rest = _objectWithoutProperties(_ref, [\"children\"]);\n\n    function isVideoChild(c) {\n      if (c.props && c.props.isVideoChild) {\n        return true;\n      }\n\n      return c.type === 'source' || c.type === 'track';\n    }\n\n    function renderChildren() {\n      const props = _objectSpread(_objectSpread({}, rest), {}, {\n        video: videoNode.current\n      }); // to make sure the children can get video property\n\n\n      if (!videoNode.current) {\n        return null;\n      } // only keep <source />, <track />, <MyComponent isVideoChild /> elements\n\n\n      return React.Children.toArray(children).filter(isVideoChild).map((c, index) => {\n        let cprops;\n        console.log(c);\n\n        if (typeof c.type === 'string') {\n          // add onError to <source />\n          if (c.type === 'source') {\n            cprops = _objectSpread(_objectSpread({}, c.props), {}, {\n              ref: index\n            });\n            const preOnError = cprops.onError;\n\n            cprops.onError = (...args) => {\n              if (preOnError) {\n                preOnError(...args);\n              }\n\n              console.error(args);\n            };\n          }\n        } else {\n          cprops = _objectSpread(_objectSpread({}, props), {}, {\n            ref: index\n          });\n        }\n\n        return /*#__PURE__*/React.cloneElement(c, cprops);\n      });\n    }\n\n    return /*#__PURE__*/_jsxDEV(\"video\", _objectSpread(_objectSpread({\n      ref: videoNode,\n      crossOrigin: \"anonymous\"\n    }, rest), {}, {\n      children: renderChildren()\n    }), changedKey, false, {\n      fileName: _jsxFileName,\n      lineNumber: 220,\n      columnNumber: 9\n    }, this);\n  }, [changedKey]);\n  return {\n    Video,\n    ready,\n    player: videoNode.current\n  };\n};","map":{"version":3,"sources":["/Users/joel/Code/joelhooks/cueplayer-react/src/components/player.tsx"],"names":["React","Hls","create","devtools","reducer","state","action","type","currentCaption","text","currentTime","player","duration","usePlayerStore","set","dispatch","args","useVideo","videoOptions","videoNode","useRef","ready","setReady","useState","changedKey","JSON","stringify","useCallback","onPlayerProgress","e","target","useEffect","fetch","current","addTextTrack","hlsConfig","enableWorker","initPlayer","video","hls","attachMedia","on","Events","MEDIA_ATTACHED","loadSource","url","MANIFEST_PARSED","event","data","console","log","levels","length","ERROR","fatal","ErrorTypes","NETWORK_ERROR","startLoad","MEDIA_ERROR","recoverMediaError","onDurationChange","onMetadataLoaded","textTracks","mode","cues","index","cue","onenter","addEventListeners","tracks","onaddtrack","track","oncuechange","activeCues","Array","from","currentTarget","kind","addEventListener","removeEventListeners","removeEventListener","isSupported","destroy","canPlayType","src","Video","children","rest","isVideoChild","c","props","renderChildren","Children","toArray","filter","map","cprops","ref","preOnError","onError","error","cloneElement"],"mappings":"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","sourcesContent":["import * as React from 'react'\nimport Hls from 'hls.js'\nimport create from 'zustand'\nimport {devtools} from 'zustand/middleware'\n\nconst reducer = (state: any, action: any) => {\n  switch (action.type) {\n    case 'SET_CAPTION':\n      return {...state, currentCaption: action.text}\n    case 'TIME_CHANGE':\n      return {...state, currentTime: action.currentTime}\n    case 'PLAYER_UPDATE':\n      return {...state, player: action.player}\n    case 'SET_DURATION':\n      return {...state, duration: action.duration}\n  }\n}\n\nexport const usePlayerStore = create(\n  devtools((set) => ({\n    player: null,\n    currentTime: 0,\n    duration: 0,\n    currentCaption: ' ',\n    dispatch: (args: any) => set((state: any) => reducer(state, args)),\n  })),\n)\n\nexport const useVideo = (videoOptions: any) => {\n  const videoNode = React.useRef<HTMLMediaElement>()\n  const [ready, setReady] = React.useState(false)\n  const changedKey = JSON.stringify(videoOptions)\n\n  const dispatch: any = usePlayerStore(\n    React.useCallback((state) => state.dispatch, []),\n  )\n\n  const onPlayerProgress = React.useCallback(\n    (e: any) => {\n      const player = e.target as HTMLMediaElement\n      dispatch({type: 'TIME_CHANGE', currentTime: player.currentTime})\n    },\n    [dispatch],\n  )\n\n  React.useEffect(() => {\n    fetch('/notes.vtt')\n    videoNode.current?.addTextTrack('metadata', 'notes')\n  }, [videoNode])\n\n  React.useEffect(() => {\n    const player: any = videoNode.current\n    const hlsConfig = {enableWorker: true}\n\n    function initPlayer(video: HTMLMediaElement) {\n      const hls = new Hls({\n        ...hlsConfig,\n      })\n\n      hls.attachMedia(video)\n      hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n        hls.loadSource(videoOptions.url)\n        hls.on(Hls.Events.MANIFEST_PARSED, function (event:any, data:any) {\n          console.log(\n            'manifest loaded, found ' + data.levels.length + ' quality level',\n            data.levels,\n          )\n\n          setReady(true)\n        })\n      })\n\n      hls.on(Hls.Events.ERROR, function (event:any, data:any) {\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              hls.startLoad()\n              break\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              hls.recoverMediaError()\n              break\n            default:\n              initPlayer(video)\n              break\n          }\n        }\n      })\n\n      return hls\n    }\n\n    function onDurationChange() {\n      dispatch({type: 'SET_DURATION', duration: player?.duration || 0})\n    }\n\n    function onMetadataLoaded() {\n      const textTracks: any = player?.textTracks[0]\n      textTracks.mode = 'hidden'\n      const cues = textTracks.cues\n\n      for (let index = 0; index < cues.length; index++) {\n        var cue = cues[index]\n        cue.onenter = (e: any) => {\n          const cue = e.target\n          dispatch({type: 'SET_CAPTION', text: cue.text})\n        }\n        // cue.onexit = cueExit\n      }\n    }\n\n    function addEventListeners() {\n      const tracks = player.textTracks\n      tracks.onaddtrack = (e: any) => {\n        const track = e.track\n        track.oncuechange = (e: any) => {\n          const activeCues = Array.from(e.currentTarget.activeCues)\n          const cue: any = activeCues[0]\n\n          if(!cue) return\n\n          switch (track.kind) {\n            case 'subtitles':\n\n              track.mode = 'hidden'\n              // if(cue) {\n              //   dispatch({type: 'SET_CAPTION', text: cue.text})\n              // } else {\n              //   dispatch({type: 'SET_CAPTION', text: ''})\n              // }\n              break;\n            case 'metadata':\n              console.log(cue)\n              console.log(cue.text)\n              break;\n          }\n\n        }\n      }\n\n      player.addEventListener('timeupdate', onPlayerProgress)\n      player.addEventListener('durationchange', onDurationChange)\n      player?.addEventListener('loadedmetadata', onMetadataLoaded)\n    }\n\n    function removeEventListeners() {\n      player?.removeEventListener('timeupdate', onPlayerProgress)\n      player?.removeEventListener('durationchange', onDurationChange)\n      player?.removeEventListener('loadedmetadata', onMetadataLoaded)\n    }\n\n    if (Hls.isSupported()) {\n      const hls = player && initPlayer(player)\n      dispatch({type: 'PLAYER_UPDATE', player})\n      addEventListeners()\n\n      return () => {\n        if (hls != null) {\n          hls.destroy()\n        }\n        removeEventListeners()\n      }\n    } else if (player?.canPlayType('application/vnd.apple.mpegurl')) {\n      // we have to branch on ios because it plays hls natively\n      // and requires a different approach ðŸ˜­\n      player.src = videoOptions.url\n      setReady(true)\n      addEventListeners()\n\n      return () => {\n        removeEventListeners()\n      }\n    }\n  }, [videoOptions, videoNode, dispatch, onPlayerProgress])\n\n  const Video = React.useCallback(\n    ({children, ...rest}) => {\n      function isVideoChild(c: any) {\n        if (c.props && c.props.isVideoChild) {\n          return true;\n        }\n        return c.type === 'source' || c.type === 'track';\n      }\n\n      function renderChildren() {\n        const props = {\n          ...rest,\n          video: videoNode.current\n        };\n\n        // to make sure the children can get video property\n        if (!videoNode.current) {\n          return null;\n        }\n\n        // only keep <source />, <track />, <MyComponent isVideoChild /> elements\n        return React.Children.toArray(children)\n            .filter(isVideoChild)\n            .map((c:any, index: number) => {\n              let cprops;\n              console.log(c)\n              if (typeof c.type === 'string') {\n                // add onError to <source />\n                if (c.type === 'source') {\n                  cprops = { ...c.props, ref: index };\n                  const preOnError = cprops.onError;\n                  cprops.onError = (...args: any[]) => {\n                    if (preOnError) {\n                      preOnError(...args);\n                    }\n                    console.error(args);\n                  };\n                }\n              } else {\n                cprops = {...props, ref: index};\n              }\n              return React.cloneElement(c, cprops);\n            });\n      }\n      return (\n        <video\n          key={changedKey}\n          ref={videoNode}\n          crossOrigin=\"anonymous\"\n          {...rest}\n        >\n          {renderChildren()}\n        </video>\n      )\n    },\n    [changedKey],\n  )\n  return {Video, ready, player: videoNode.current}\n}\n"]},"metadata":{},"sourceType":"module"}