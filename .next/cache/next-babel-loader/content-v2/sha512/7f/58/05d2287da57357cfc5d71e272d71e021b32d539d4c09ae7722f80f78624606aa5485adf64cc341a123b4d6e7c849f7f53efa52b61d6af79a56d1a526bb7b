{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport _objectWithoutProperties from \"/Users/joel/Code/joelhooks/cueplayer-react/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"/Users/joel/Code/joelhooks/cueplayer-react/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/joel/Code/joelhooks/cueplayer-react/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport Hls from 'hls.js';\nimport create from 'zustand';\nimport { devtools } from 'zustand/middleware';\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'SET_CAPTION':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentCaption: action.text\n      });\n\n    case 'TIME_CHANGE':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        currentTime: action.currentTime\n      });\n\n    case 'PLAYER_UPDATE':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        player: action.player\n      });\n\n    case 'SET_DURATION':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        duration: action.duration\n      });\n  }\n};\n\nexport var usePlayerStore = create(devtools(function (set) {\n  return {\n    player: null,\n    currentTime: 0,\n    duration: 0,\n    currentCaption: ' ',\n    dispatch: function dispatch(args) {\n      return set(function (state) {\n        return reducer(state, args);\n      });\n    }\n  };\n}));\nexport var useVideo = function useVideo(videoOptions) {\n  var videoNode = React.useRef();\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      ready = _React$useState2[0],\n      setReady = _React$useState2[1];\n\n  var changedKey = JSON.stringify(videoOptions);\n  var dispatch = usePlayerStore(React.useCallback(function (state) {\n    return state.dispatch;\n  }, []));\n  var onPlayerProgress = React.useCallback(function (e) {\n    var player = e.target;\n    dispatch({\n      type: 'TIME_CHANGE',\n      currentTime: player.currentTime\n    });\n  }, [dispatch]);\n  React.useEffect(function () {\n    var _videoNode$current;\n\n    fetch('/notes.vtt');\n    (_videoNode$current = videoNode.current) === null || _videoNode$current === void 0 ? void 0 : _videoNode$current.addTextTrack('metadata', 'notes');\n  }, [videoNode]);\n  React.useEffect(function () {\n    var player = videoNode.current;\n    var hlsConfig = {\n      enableWorker: true\n    };\n\n    function initPlayer(video) {\n      var hls = new Hls(_objectSpread({}, hlsConfig));\n      hls.attachMedia(video);\n      hls.on(Hls.Events.MEDIA_ATTACHED, function () {\n        hls.loadSource(videoOptions.url);\n        hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {\n          console.log('manifest loaded, found ' + data.levels.length + ' quality level', data.levels);\n          setReady(true);\n        });\n      });\n      hls.on(Hls.Events.ERROR, function (event, data) {\n        if (data.fatal) {\n          switch (data.type) {\n            case Hls.ErrorTypes.NETWORK_ERROR:\n              hls.startLoad();\n              break;\n\n            case Hls.ErrorTypes.MEDIA_ERROR:\n              hls.recoverMediaError();\n              break;\n\n            default:\n              initPlayer(video);\n              break;\n          }\n        }\n      });\n      return hls;\n    }\n\n    function onDurationChange() {\n      dispatch({\n        type: 'SET_DURATION',\n        duration: (player === null || player === void 0 ? void 0 : player.duration) || 0\n      });\n    }\n\n    function onMetadataLoaded() {\n      var textTracks = player === null || player === void 0 ? void 0 : player.textTracks[0];\n      textTracks.mode = 'hidden';\n      var cues = textTracks.cues;\n\n      for (var index = 0; index < cues.length; index++) {\n        var cue = cues[index];\n\n        cue.onenter = function (e) {\n          var cue = e.target;\n          dispatch({\n            type: 'SET_CAPTION',\n            text: cue.text\n          });\n        }; // cue.onexit = cueExit\n\n      }\n    }\n\n    function addEventListeners() {\n      var tracks = player.textTracks;\n\n      tracks.onaddtrack = function (e) {\n        var track = e.track;\n\n        track.oncuechange = function (e) {\n          var activeCues = Array.from(e.currentTarget.activeCues);\n          var cue = activeCues[0];\n          if (!cue) return;\n\n          switch (track.kind) {\n            case 'subtitles':\n              track.mode = 'hidden'; // if(cue) {\n              //   dispatch({type: 'SET_CAPTION', text: cue.text})\n              // } else {\n              //   dispatch({type: 'SET_CAPTION', text: ''})\n              // }\n\n              break;\n\n            case 'metadata':\n              console.log(cue);\n              console.log(cue.text);\n              break;\n          }\n        };\n      };\n\n      player.addEventListener('timeupdate', onPlayerProgress);\n      player.addEventListener('durationchange', onDurationChange);\n      player === null || player === void 0 ? void 0 : player.addEventListener('loadedmetadata', onMetadataLoaded);\n    }\n\n    function removeEventListeners() {\n      player === null || player === void 0 ? void 0 : player.removeEventListener('timeupdate', onPlayerProgress);\n      player === null || player === void 0 ? void 0 : player.removeEventListener('durationchange', onDurationChange);\n      player === null || player === void 0 ? void 0 : player.removeEventListener('loadedmetadata', onMetadataLoaded);\n    }\n\n    if (Hls.isSupported()) {\n      var hls = player && initPlayer(player);\n      dispatch({\n        type: 'PLAYER_UPDATE',\n        player: player\n      });\n      addEventListeners();\n      return function () {\n        if (hls != null) {\n          hls.destroy();\n        }\n\n        removeEventListeners();\n      };\n    } else if (player !== null && player !== void 0 && player.canPlayType('application/vnd.apple.mpegurl')) {\n      // we have to branch on ios because it plays hls natively\n      // and requires a different approach ðŸ˜­\n      player.src = videoOptions.url;\n      setReady(true);\n      addEventListeners();\n      return function () {\n        removeEventListeners();\n      };\n    }\n  }, [videoOptions, videoNode, dispatch, onPlayerProgress]);\n  var Video = React.useCallback(function (_ref) {\n    var children = _ref.children,\n        rest = _objectWithoutProperties(_ref, [\"children\"]);\n\n    function isVideoChild(c) {\n      if (c.props && c.props.isVideoChild) {\n        return true;\n      }\n\n      return c.type === 'source' || c.type === 'track';\n    }\n\n    function renderChildren() {\n      var props = _objectSpread(_objectSpread({}, rest), {}, {\n        video: videoNode.current\n      }); // to make sure the children can get video property\n\n\n      if (!videoNode.current) {\n        return null;\n      } // only keep <source />, <track />, <MyComponent isVideoChild /> elements\n\n\n      return React.Children.toArray(children).filter(isVideoChild).map(function (c, index) {\n        var cprops;\n        console.log(c);\n\n        if (typeof c.type === 'string') {\n          // add onError to <source />\n          if (c.type === 'source') {\n            cprops = _objectSpread(_objectSpread({}, c.props), {}, {\n              ref: index\n            });\n            var preOnError = cprops.onError;\n\n            cprops.onError = function () {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              if (preOnError) {\n                preOnError.apply(void 0, args);\n              }\n\n              console.error(args);\n            };\n          }\n        } else {\n          cprops = _objectSpread(_objectSpread({}, props), {}, {\n            ref: index\n          });\n        }\n\n        return /*#__PURE__*/React.cloneElement(c, cprops);\n      });\n    }\n\n    return /*#__PURE__*/_jsx(\"video\", _objectSpread(_objectSpread({\n      ref: videoNode,\n      crossOrigin: \"anonymous\"\n    }, rest), {}, {\n      children: renderChildren()\n    }), changedKey);\n  }, [changedKey]);\n  return {\n    Video: Video,\n    ready: ready,\n    player: videoNode.current\n  };\n};","map":null,"metadata":{},"sourceType":"module"}